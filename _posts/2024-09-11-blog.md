---
title: '代码随想录算法训练营 Day 13'
date: 2024-09-11
permalink: /posts/2024/09/blog-post-9/
tags:
- LeetCode
- 代码随想录
- 二叉树
---

## 进一步掌握递归法和迭代法

## Q1. [LeetCode 110](https://leetcode.com/problems/balanced-binary-tree/)

解法1. 递归法

```
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        return self.getDepth(root, 0)[0]
    
    def getDepth(self, node, depth):
        if not node:
            return [True, depth]
        
        # 单层判断逻辑：1. 获取当前的左右子树的高度，以及是否平衡；2. 根据左右平衡与左右子树高度确定是否平衡
        left_balanced, left_dep = self.getDepth(node.left, depth + 1)
        right_balanced, right_dep = self.getDepth(node.right, depth + 1)

        balanced = left_balanced and right_balanced and abs(left_dep - right_dep) <= 1
        
        # 返回结果中带有两个变量：是否平衡，最大深度
        return [balanced, max(left_dep, right_dep)]
```

---

解法2: 迭代法

```
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        height_map = {}
        stack = [root]
        while stack:
            # 利用None值做标记，只有遇到None值，下一个节点才是需要处理的节点
            node = stack.pop()
            if node:
                stack.append(node)
                stack.append(None)
                if node.right: 
                    stack.append(node.right)
                if node.left: 
                    stack.append(node.left)
            else:
                real_node = stack.pop()
                left, right = height_map.get(real_node.left, 0), height_map.get(real_node.right, 0)
                if abs(left - right) > 1:
                    return False
                height_map[real_node] = 1 + max(left, right)
        return True
```

### Take some notes

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。（通常使用前序遍历）
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。（通常使用后序遍历）

## Q2. [LeetCode 257](https://leetcode.cn/problems/binary-tree-paths/)

## Q3. [LeetCode 404](https://leetcode.cn/problems/sum-of-left-leaves/)

## Q4. [LeetCode 222](https://leetcode.cn/problems/count-complete-tree-nodes/)
