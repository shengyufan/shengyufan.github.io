---
title: '代码随想录算法训练营 Day 23'
date: 2024-09-23
permalink: /posts/2024/09/blog-post-19/
tags:
- LeetCode
- 代码随想录
- 贪心算法
---

## 贪心算法

解题步骤：
1. 将问题分解为若干个子问题
2. 找出适合的贪心策略
3. 求解每一个子问题的最优解
4. 将局部最优解堆叠成全局最优解

## Q1. [LeetCode 455](https://leetcode.com/problems/assign-cookies/)

用大饼干满足大胃口的孩子，用小饼干满足小胃口的孩子

*注意两种解法的区别（遍历数组）*

```
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        res = 0
        idx = len(s) - 1

        for i in range(len(g) - 1, -1, -1):
            if idx >= 0 and s[idx] >= g[i]:
                res += 1
                idx -= 1
        
        return res
```

---

```
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        res = 0
        idx = 0

        for i in range(len(s)):
            if idx < len(g) and s[i] >= g[idx]:
                res += 1
                idx += 1
        
        return res
```

### 复杂度分析

时间复杂度：O($nlogn$)
空间复杂度：O(1)

## Q2. [LeetCode 376](https://leetcode.com/problems/wiggle-subsequence/)

题目要求返回的是所有排列，而排列是有序的 (e.g. $[1,2]$和$[2,1]$两者不同)，因此每次都需要从头遍历

```
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []

        # used数组表示对应位置的元素是否已被使用
        def backtracking(used, arr):
            if sum(used) == len(nums):
                res.append(arr[:])
                return
            
            for i in range(len(nums)):
                if used[i]:
                    continue
                
                used[i] = 1
                arr.append(nums[i])
                backtracking(used, arr)
                arr.pop()
                used[i] = 0
        
        backtracking([0] * len(nums), [])

        return res
```

### 复杂度分析

时间复杂度：O($n!$)
空间复杂度：O($n$)

## Q3. [LeetCode 53](https://leetcode.com/problems/permutations-ii/)

注意两种去重的逻辑，理解为什么第二种更高效。参考[代码随想录](https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%8B%93%E5%B1%95)

```
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()

        # used数组表示对应位置的元素是否已被使用
        def backtracking(used, arr):
            if sum(used) == len(nums):
                res.append(arr[:])
                return
            
            for i in range(len(nums)):
                if (i > 0 and nums[i] == nums[i - 1] and used[i - 1]) or used[i]:
                    continue
                
                used[i] = 1
                arr.append(nums[i])
                backtracking(used, arr)
                arr.pop()
                used[i] = 0
        
        backtracking([0] * len(nums), [])

        return res
```

---

```
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()

        # used数组表示对应位置的元素是否已被使用
        def backtracking(used, arr):
            if sum(used) == len(nums):
                res.append(arr[:])
                return
            
            for i in range(len(nums)):
                if (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]) or used[i]:
                    continue
                
                used[i] = 1
                arr.append(nums[i])
                backtracking(used, arr)
                arr.pop()
                used[i] = 0
        
        backtracking([0] * len(nums), [])

        return res
```

### 复杂度分析

时间复杂度：O($n! \times n$)
空间复杂度：O($n$)
